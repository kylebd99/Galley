# This file is a part of Julia. License is MIT: https://julialang.org/license
using Base: union!, union, setdiff!, setdiff, intersect!, intersect, eltype, empty
using Base: emptymutable, copy, copymutable,push!, delete!, empty!, isempty,in,issubset
using Base: ⊊,==,iterate, length, hash
Bits = UInt128
mutable struct SmallBitSet <: AbstractSet{Int}
    bits::Bits
    SmallBitSet() = new(0)
end

"""
    SmallBitSet([itr])

Construct a sorted set of `Int`s generated by the given iterable object, or an
empty set. Implemented as a static bit string, and therefore designed for integers between
1 and 128.
"""

SmallBitSet(itr) = union!(SmallBitSet(), itr)

# Special implementation for BitSet, which lacks a fast `length` method.
function Base.union!(s::SmallBitSet, itr)
    for x in itr
        push!(s, x)
    end
    return s
end


Base.eltype(::Type{SmallBitSet}) = Int

Base.empty(s::SmallBitSet, ::Type{Int}=Int) = SmallBitSet()
Base.emptymutable(s::SmallBitSet, ::Type{Int}=Int) = SmallBitSet()

Base.copy(s1::SmallBitSet) = Base.copy!(SmallBitSet(), s1)
Base.copymutable(s::SmallBitSet) = Base.copy(s)

function Base.copy!(dest::SmallBitSet, src::SmallBitSet)
    dest.bits = src.bits
    dest
end

@inline _mod128(l) = l & 127
function _bits_getindex(b::Bits, n::Int)
    @inbounds r = (b & (one(UInt128) << _mod128(n))) != 0
    r
end

# An internal function for setting the inclusion bit for a given integer
@inline function _setint!(s::SmallBitSet, idx::Int, b::Bool)
    u = UInt128(1) << idx
    s.bits = ifelse(b, s.bits | u, s.bits & ~u)
    s
end

@noinline _throw_bitset_bounds_err() =
    throw(ArgumentError("elements of SmallBitSet must be between 0 and 128"))

@inline _is_convertible_Int(n) = 0 < n <= 128

@inline _check_bitset_bounds(n) =
    _is_convertible_Int(n) ? Int(n) : _throw_bitset_bounds_err()

@inline _check_bitset_bounds(n::Int) = n

@noinline _throw_keyerror(n) = throw(KeyError(n))

@inline Base.push!(s::SmallBitSet, n::Integer) = _setint!(s, _check_bitset_bounds(n), true)

Base.push!(s::SmallBitSet, ns::Integer...) = (for n in ns; push!(s, n); end; s)

@inline Base.delete!(s::SmallBitSet, n::Integer) = _is_convertible_Int(n) ? delete!(s, Int(n)) : s

function Base.empty!(s::SmallBitSet)
    s.bits = 0
    s
end

Base.isempty(s::SmallBitSet) = s.bits == 0

# Mathematical set functions: union!, intersect!, setdiff!, symdiff!

Base.union(s::SmallBitSet, sets...) = union!(copy(s), sets...)
function Base.union!(s1::SmallBitSet, s2::SmallBitSet)
    s1.bits |= s2.bits
    s1
end

Base.intersect(s1::SmallBitSet, s2::SmallBitSet) =  intersect!(copy(s1), s2)

function Base.intersect!(s1::SmallBitSet, s2::SmallBitSet)
    s1.bits &= s2.bits
    s1
end

Base.setdiff(s1::SmallBitSet, s2::SmallBitSet) = setdiff!(copy(s1), s2)
function Base.setdiff!(s1::SmallBitSet, s2::SmallBitSet)
    s1.bits &= ~s2.bits
    s1
end

@inline Base.in(n::Integer, s::SmallBitSet) = _is_convertible_Int(n) ? _bits_getindex(s.bits, Int(n)) : false

function Base.iterate(s::SmallBitSet, idx = 0)
    word = 0
    while word == 0
        idx == 128 && return nothing
        idx += 1
        word = s.bits & (one(UInt128) << idx)
    end
    idx, idx
end

function Base.length(s::SmallBitSet)
    n = 0
    for x in s
        n += 1
    end
    n
end

@noinline _throw_bitset_notempty_error() =
    throw(ArgumentError("collection must be non-empty"))

function Base.:(==)(s1::SmallBitSet, s2::SmallBitSet)
    return s1.bits == s2.bits
end

Base.issubset(a::SmallBitSet, b::SmallBitSet) = a == intersect(a,b)
Base.:(⊊)(a::SmallBitSet, b::SmallBitSet) = a <= b && a != b

function Base.hash(s::SmallBitSet)
    return hash(s.bits)
end

function Base.hash(s::SmallBitSet, h::UInt128)
    return hash(s.bits, h)
end

function Base.hash(s::SmallBitSet, h::UInt64)
    return hash(s.bits, h)
end
